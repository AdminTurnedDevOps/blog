---
title: "Building And Deploying NodeJS Applications"
description: Just because you are using nodejs, it's no reason to violate the principle of build-once, deploy-many
author: robert.erez@octopus.com
visibility: private
tags:
 - New Releases
---

NodeJS has become one of the hottest programing languages to work with in recent years. Javascript has constantly been ranked as the most popular programming language in the Stack Overflow developer surveys for the past few years and its not hard to see why.
The ubiquity of JavaScript as the front-end language for the web means that is used and understood (citation needed) by developers regardless if they come from a background of Java, C# or Ruby. The number of developers out there who already know JavaScript means that the community is huge with libraries and frameworks for every possible requirement, so it stands to reason that using it for server-side projects sometimes seems like the right approach.

![NodeJS is so hot right now](nodejs_so_hot.jpg)

For some reason though, when moving from a compiled to a scripted language many programmers seem to leave their good habits at the door. It's all too common to see NodeJS applications (or pure JavaScript applications that use NodeJS as the development environment) where the developers commit their code into GitHub, then pull down the source code directly from GitHub on their production servers to be followed by an `npm install` and `<grunt|gulp|webpack|next-big-thing> build`. Often they are diligent enough to write tests (because we all do TDD right?) but figure it's just easier to rebuild their application each time they deploy it.

By using a [semver](https://docs.npmjs.com/misc/semver) range in your `packages.json` file, you may end up in a situation where your config says some dependant package needs `~4.17.2`, so your development machine pulls down `4.17.3`, tests are run against `4.17.4` and by the time production is deployed, the author has made another update and so your production software is running `4.17.9`. I say again, production! There are plenty of cases of library authors accidentally (or by design) pushing breaking changes with a corresponding version bump that results in consuming code crashing due to broad version matching. This problem is somewhat mitigated by the addition of the [`package-lock`](https://docs.npmjs.com/files/package-lock.json) feature that was introduced into npm 5. **Make sure you commit this file to source control**. (As a side note, npm has come a long way and many of the reasons to prefer [yarn](https://yarnpkg.com/en/) are no longer applicable.)

Every time you deploy the application YOU ARE DOWNLOADING NEW, POTENTIALLY UNTESTED DEPENDENCIES! And thats if everything goes well. Even though npm no longer supports pushing new files to existing versions I have heard of more than one occasion where production releases fail because the packages were unable to be downloaded due to npm being temporarily down or, ya know.... networks stuff. This failure to install is often accompanied by overwriting the old version, resulting in a server that is effectively worthless (or worse) until access to npm is restored. In one case a user was performing this "fresh install" process each time their AWS Elastic Beanstalk tried to spin up a new web server when the exiting farm was under load. The inability to bring new servers online to serve the traffic ended up killing the whole website. This is _after_ the original deployment had already "succeeded" many days ago.

## Packaging your NodeJs app
Thats right, you should be packaging up your JavaScript applications in the same way you would expect to see for your other apps.
Octopus had a tool that you can use that may help with that

I could just run
```
> git clone blah
> cd blah
> npm install
> npm build
... Do stuff to ZIP ../blah
```
but then I would end up with a file 6MB in size, most of which contains the various libraries I used for debugging and compiling. I dont need all the typescript compliers, webpack libraries and testing frameworks once everything has been built and is ready to be run in production, but how do we separate the dev-time dependencies from the production dependencies? If you run the [`npm prune --production`](https://docs.npmjs.com/cli/prune) then npm will remove all the packages from `node_modules` that are specified in the `devDependencies` section of your `package.json`. Even if you dont use our tooling, I would recommend running this command and zip up your entire project folder into an archive for your CD system, wether that be using Octopus Deploy, VSTS, Chef or some manual process.

Octopus Deploy has published a nodejs cli tool, [octojs](https://github.com/OctopusDeploy/octojs) that makes the packaging process simpler by creating the zip (or tar.gz) archive without having to perform this prune step. The package name is generated by default using the name and version in your project's `package.json` however these values can all be overridden. `Octojs` can be used directly through the console or imported and used in code as part of the build process.

### Package via command line
 The easiest way to use the tool is to install it globally

```
> npm install -g @octopusdeploy/octojs
```

from within any project `octojs` can then be invoked to package the application. Assuming the `RandomQuotes` package above has just been built, packaging my application is as simple as

```
> octojs pack -O C:\Bin --gitignore --dependencies prod

Created package C:\Bin\ramdomquotes.1.0.0.zip (1.66 MB)
```

The size of the generated package is now much smaller, and the package Id and version are generated from the project itself. With the package now generated we can push it directly to the Octopus Deploy built in feed for deployment.

```
> octojs push --package C:\Bin\ramdomquotes.1.0.0.zip --server http://octopusserver.acme.com --apiKey API-F2K29BA08AA123
```

### Package via code
Alternatively, you can use this library to pack and push your project in multiple steps or in one hit through code.

```JavaScript
var octo = require("@octopusdeploy/octojs");
octo.pack({dependencies: 'prod', bypassDisk: true, root: "."},
    (err, data) => {
            console.log("Uploading package: "+ data.name);
            octo.push(data.stream, {
                apiKey: 'API-F2K29BA08AA123 ',
                server: 'http://octopusserver.acme.com',
                name: data.name
            }, () => console.log("Uploaded"));
        }
    })
    .append('hello.txt', new Buffer('This Is An Additional File'))
    .finalize(true);
```

There are [gulp](https://github.com/OctopusDeploy/gulp-octo) and [grunt](https://github.com/OctopusDeploy/grunt-octo) versions of these libraries that will help package your project during your build process (with a webpack one on the way). 



WebAssembly stands to help make a lot of developers start thinking about parts of their front-end code the same way they do their back-end code. The compilation takes place on a dedicated build server with the resulting artifacts are built once and deployed to each environment. In some ways I'm hoping the use of WebAssembly is constrained to projects where performance is critical. One of the greatest benefits of being constrained to JavaScript to the browser, is that despite all it's limitations, confusing scopes, it serves as the lingua franca between developers from all other languages. I can use frameworks and tools built and used but people developing Haskell applications and we all benefit from the huge pool of talent and ideas out there. Once we all go back into our siloed languages, we all lose something.

* simple to throw together
* huge library

* left-pad errors: https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/
* Security concerns in libraries -> You are 

