---
title: Choas engineering and Runbooks
description: Learn how Runbooks can enrich your deployments with the Chaos Toolkit
author: matthew.casperson@octopus.com
visibility: private
published: 2999-01-01
metaImage:
bannerImage:
tags:
 - Octopus
---

The promise of declarative systems that automatically reconfigure themselves to the desired state is that most faults that result in resources stopping or being destroyed will be rectified without any manual intervention. Kubernetes is a perfect example of this, where deleted pods in a deployment will be recreated as the deployment brings the cluster back to the desired state.

Proving that a system can tolerate failure of individual components is the essence of chaos engineering. In his talk [BoF Deep Dive: Chaos Engineering](https://youtu.be/Qus15C5vT5Y?list=PLj6h78yzYM2PpmMAnvpvsnR4c27wJePh3&t=1447) Sylvain Hellegouarch, the creator of the [Chaos Toolkit](https://chaostoolkit.org/), provides an overview of how to apply chaos engineering to Kubernetes. While the technical details of this talk are valuable, it was the advice he gave about how and when to run chaos experiments that is of most interest to Octopus users (this is 24 minutes into the talk):

> Don't necessarily tie your chaos engineering to your deployment. Run that part orthogonally.

> You should always have chaos engineering that runs constantly, because the problem with doing [chaos engineering] at rollout is that your system lives between your deployments. It evolves, so keep changing the system as you run.

Until recently, running any kind of automated process in Octopus meant creating a deployment. It was possible to hack the idea of a deployment to implement management tasks, but it was awkward.

With Runbooks, Octopus now has first class support for running management tasks in parallel to deployments. You get access to all the existing environments, variables, targets, steps, security, auditing and reporting, but without being tied to the concept of a deployment or a lifecycle.

This makes Runbooks ideal for running tools like the Chaos Engineering toolkit. In this post we'll create a very simple chaos experiment as a Runbook, and call out the advantages Runbooks provide for this kind of task.

## The Kubernetes deployment

 We'll start by creating a deployment process that will spin up a number of pods on a Kubernetes cluster. This is implemented with the *Deploy Kubernetes containers* step in Octopus. In the screenshot below you can see that we have created a single deployment that creates 10 NGINX pods.

 ![](k8s-step.png "width=500")

 ## The chaos Runbook

 Alongside the deployment we also have a runbook that executes a simple Chaos Toolkit experiment which deletes a pod and ensures that the deployment is healthy using the [microservice_available_and_healthy](https://docs.chaostoolkit.org/drivers/kubernetes/#microservice_available_and_healthy) function.

 Once the test is completed, a PDF [report](https://docs.chaostoolkit.org/reference/usage/report/) is generated showing the results of the experiment. The output generated by the `chaos` tool and the report are captured as artifacts.

 ```PowerShell
 Set-Content -Path experiment.json -Value @"
 {
     "title": "Do we remain available in face of pod going down?",
     "description": "We expect Kubernetes to handle the situation gracefully when a pod goes down",
     "tags": ["kubernetes"],
     "steady-state-hypothesis": {
         "title": "Verifying service remains healthy",
         "probes": [
             {
                 "name": "all-our-microservices-should-be-healthy",
                 "type": "probe",
                 "tolerance": true,
                 "provider": {
                     "type": "python",
                     "module": "chaosk8s.probes",
                     "func": "microservice_available_and_healthy",
                     "arguments": {
                         "name": "myapp"
                     }
                 }
             }
         ]
     },
     "method": [
         {
             "type": "action",
             "name": "terminate-db-pod",
             "provider": {
                 "type": "python",
                 "module": "chaosk8s.pod.actions",
                 "func": "terminate_pods",
                 "arguments": {
                     "label_selector": "app=my-app",
                     "name_pattern": "my-app-[0-9]$",
                     "rand": true
                 }
             },
             "pauses": {
                 "after": 5
             }
         }
     ]
 }
 "@
 chaos run experiment.json
 docker run `
     -v "$(Get-Location):/tmp/result" `
     -it `
     chaostoolkit/reporting
 New-OctopusArtifact journal.json
 New-OctopusArtifact report.pdf
 ```

![](chaos-runbook.png "width=500")

Here is the result of the runbook execution, with the output JSON and report PDF available as artifacts.

![](runbook-results.png "width=500")

We have now successfully implemented a simple chaos engineering experiment alongside the original deployment. So what benefits does Runbooks bring to this process?

## Deployments and Runbooks side by side

By defining the deployment and the runbook in a single project, we have a single context that captures both the deployment process and any ongoing testing or management of the deployment.

From a convenience point of view this means there is a single user interface, a shared set of variables, closely linked overview dashboards, and consolidated reporting.

From a management point of view, there is a single project to configure security rules against, and a consolidated audit log.

![](filtered-audit-log.png "width=500")

Runbooks keeps the management tasks you run against deployments alongside the deployments themselves, making it easy to run, review and track the state of your infrastructure.

## Shared context

Complex Kubernetes deployments will implement namespaces to keep resources separate, and RBAC controls on service accounts to ensure rouge deployment definitions don't interfere with the rest of the cluster. When these permission boundaries are represented in Octopus Kubernetes targets, they lend themselves nicely to runbooks by ensuring management tasks are also constrained.

Like almost any CLI tool that operates with Kubernetes, Chaos Toolkit can access a cluster from the details in a Kubernetes `config` file. Octopus provides a local copy of this configuration file based on the target a deployment or runbook is executing against. So whether a deployment uses a specialized Kubernetes step or a runbook implements a general Kubernetes script, both share a single target that is defined once.

## Independent execution workflows

While sharing the same underlying context, runbooks are executed independently from deployments. Runbook define their own scheduled triggers, or can be run manually against any environment without being bound to a lifecycle.

This is ideal for chaos engineering. As Sylvain noted in his talk, chaos experiments should be run continuously between deployments to validate a cluster between deployments.

In the screenshot below the chaos experiment is being run every ten minutes to validate the cluster between deployments.

![](runbook-trigger.png "width=500")
